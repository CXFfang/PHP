模型属性  
// 声明表明，若不声明，laravel会强制表为复数形式，不然会报错，比如model名字为user，表明必须为users
````
protected $table = 'user';
````

// 系统默认主键为id，修改默认主键,系统默认id为自增性
````
protected $primaryKey = 'Xid';
````

// 意味着主键会自动转换成int类型，修改主键自增属性
````
public $incrementing = false;
````

// 主键不是整数，修改主键的属性
````
protected $keyType = 'string';
````

// 系统会默认表内有两个时间戳字段，每次都会更新，可以设置为false
````
Public $timestamps = false;
````

// 定义自定义时间戳格式
````
protected $dateFormat = 'U';
````

// 更改默认字段名
````
const CREATED_AT = '';
const UPDATED_AT = '';
````

// 更改连接数据库
````
protected $connection = 'mysql';
````

模型操作  
// 插件 模型代码提示  
````
composer require barryvdh/laravel-ide-helper 
php artisan ide-helper:generate – 为 Facades 生成注释 
php artisan ide-helper:models – 为数据模型生成注释 
php artisan ide-helper:meta – 生成 PhpStorm Meta file
````

// 查询所有数据  
````
::get();
::all();
````



// 查询条件  
````
$users = User::where([ ['gender', '=', '男'], ['price', '>', 95] ])->limit(2)->get();
````

// 查询跟控制器构造器差不多，官方示例  

(1).find(1) // 通过主键查找   
(2) .first() // 查找第一个   
(3) .firstWhere() // 找到查询中的首个   
(4) .find([1,2,3]) // 通过数组查找   
(5) .firstOr() // 查找首个返回，支持闭包   
(6) .firstOrFail() // 找不到时返回异常   
(7) .count()、max()等集合 // 集合操作  


增删改  
// 模型修改，默认模型接管 created_at 和 updated_at  
````
$users = new User();
$users->username = '辉夜';
$users->password = '123'; 
$users->email = 'huiye@163.com'; 
$users->details = '123'; $users->save();
````

// 方法2  
````
$users = User::find(321);
 $users->username = '夜辉';
 $users->save();
````

// 批量修改
````
User::where('username', '夜辉')
 ->update([
 'username' => '辉夜' 
]);
````

// 批量新增  
````
User::create(
[ 'username' => 'name',
 'password' => '123', 
'email' => 'name@163.com',
 'details' => '123', ]);
// PS：必须在模型中定义批量赋值的可填充字段，否则无法生效；防止用户不小心设置新值；
protected $fillable;// 允许批量字段
protected $guarded ;// 不允许批量字段
protected $guarded = []; // 取消批量限制
````
// 删除  
````
$users = User::find(332);
$users->delete(); // 批量删除 
````
方法2  
````
$users = User::where('username', '夜辉'); 
$users->delete();
````
方法3 通过主键删除，免查询操作 
````
User::destroy('ids'); // ids支持数组
````

// 软删除，需要默认deleted_at默认设置这个字段为空(null)，如果写入数据，成为非空状态，则说明被删除；
开启软删除  
````
use SoftDeletes;
````
// 软删除功能 当开启了软删除功能，之前的删除操作，都会变成更新操作，给 deleted_at 赋值；  
// 删除一   
````
$users = User::find(82); 
$users->delete(); 
````
// 删除二 
````
User::destroy(81);
````

当我们开启软删除后，数据获取列表会被隐藏  
// 软删除的数据不可见   
````
$users = User::get(); 
````
// 单独获取被软删除的数据不行   
````
$users = User::find(82); 
````
// 获取软删除数据  
````
::withTrashed();
````
// 获取包含软删除的数据   
````
$users = User::withTrashed()->get(); 
 ````
// 获取某个被软删除的数据(即使不是软删除的也可以搜索到)   
````
$users = User::withTrashed()->find(82); 
````




// 只搜索软删除  
````
::onlyTrashed();
````
// 获取所有软删除的数据   
````
$users = User::onlyTrashed()->get(); 
````
// 获取某个被软删除的数据(只有软删除的数据才可以被搜索到)   
````
$users = User::onlyTrashed()->find(82); 
```` 
// 软删除判断  
````
->trashed(); 
$users = User::withTrashed()->find(81); 
return $users->trashed();
````
// 软删除还原  
````
->restore();
$users = User::onlyTrashed()->find(82); 
$users->restore();
````
// 软删除强行删除  
````
->forceDelete();
$users = User::onlyTrashed()->find(82); 
$users->forceDelete();
````

模型作用域  
// 本地作用域，相当在模型中写一定的条件function，然后能在控制器中调用  
// App\Http\Models;  
 // 本地作用域，搜索自动添加为“男”的条件   
// 语法：scope 开头，后面名称尽可能包含语义   
````
public function scopeGenderMale($query) 
{ 
    return $query->where('gender', '男');
}
````
// 作用域调用  
// 当然，如果感觉单词太长，直接 gm()也行   
````
$users = User::genderMale() 
->where('price', '>', 90) 
->get();
````
// 灵活用法 参数可以是 1 个或多个   
````
$users = User::gender('女', -3)
 ->where('price', '>', 90)
 ->get(); 
````



// 参数 2 和 3，接受控制器传递过来的 1，2 
````
public function scopeGender($query, $value, $value2) 
{ 
    return $query->where('gender', $value)->where('status', $value2); 
}
````

// 全局作用域   
1. 全局作用域，顾名思义就是在任意地方都可以有效的封装条件； 
2. 比如有个需求，不管在哪里操作，总是显示 status 为 1 的用户； 
3. 首先在 app 目录下创建一个用于全局作用域的目录：Scopes； 
4. 创建一个用于设置 status 为 1 的全局作用域的类，它需要实现 scope 接口； 
namespace App\Scopes;   
// 这里引用代码自动生成   
````
use Illuminate\Database\Eloquent\Builder; 
use Illuminate\Database\Eloquent\Model; 
use Illuminate\Database\Eloquent\Scope; 
class StatusScope implements Scope 
{ 
/**
* @inheritDoc 
*/ 
public function apply(Builder $builder, Model $model) 
{ 
//  
TODO: Implement apply() method. 
return $builder->where('status', 1); 
} 
} 
````
5.此时，还不能实现全局，因为需要在模型设置个开关，让其富有灵活性；   
// 启用全局作用域   
````
protected static function booted() 
{ 
    parent::booted(); //  TODO: 
    Change the autogenerated stub 
    static::addGlobalScope(new 
    StatusScope()); 
}
````
PS：而在控制器端，并不需要做任何设置，即可自动添加 status=1 的条件；   
6.当然，如果这个全局只是针对某个模块，并不需要创建一个全局类，直接闭包即可； 
````
static::addGlobalScope('status', function (Builder $builder) { 
    return $builder->where('status', 1); 
}); 
````
PS：注意 Builder 引入的文件和全局类引入的文件一致，如果引入别的同名类会错；    

7.如果某个查询，并不需要这个全局条件，可以单独移出掉；     
// 取消名称为 status 的全局   
````
$users = User::withoutGlobalScope('status')->get(); 
````
// 取消全局类的条件   
````
$users = User::withoutGlobalScope(StatusScope::class)->get(); 
````
PS：还有 withoutGlobalScopes([])方法，传递参数取消多个全局；


访问器和修改器  
一．访问器   
1. 访问器：就是在获取数据列表时，拦截属性并对属性进行修改的过程；   
2. 比如，我们在输出性别时，在性别左右加上括号，或给邮件转换为大写；   
// 访问器，前固定 get，后固定 Attribute，Gender 是字段名   
// 参数$value 是源字段值，可修改返回   
````
public function getGenderAttribute($value) 
{ 
    return '【'.$value.'】'; 
}
````  
PS：如果字段名是两个单词中间是下划线:user_name，那么方法名：getUserNameAttribute()   
3. 我们也可以创建一个虚拟字段，用已有的数据字段进行整合，不过要进行数据追加；   
// 将虚拟字段追加到数据对象列表里去   
````
protected $appends = ['info']; 
````
// 创建一个虚拟字段   
````
public function getInfoAttribute() 
{ 
    return $this->username.'-'.$this->gender; 
}
````
PS：注意，如果 gender 之前已经有访问器修改过，上面的方法会得到修改过的结果；   
PS：如果要使用源字段进行创建虚拟字段，需要使用下面这种：   
````
return $this->attributes['username'].'-'.$this->attributes['gender']; 
````

二．修改器     
1. 修改器，相对于访问器，是在写入的时候拦截，进行修改再写入；   
// 修改器，写入数据时，将邮箱转换为大写   
````
public function setEmailAttribute($value) 
{ 
    $this->attributes['email'] = strtoupper($value); 
}
````


2. 可以添加默认的日期列，默认 created_at 和 updated_at；   
// 设置可以自动写入日期的列   
````
protected $dates = [ 
    'details' 
]; 
````
3. 可以设置字段输出的类型，比如设置一个布尔型，输出时就是 true 和 false；   
// 设置字段类型   
````
protected $casts = [ 'details' => 'boolean'];
````